Порівняємо за допомогою програми ефективність цих двох алгоритмів - "жадібного" і "динамічного програмування".
У даному конкретному випадку, коли ми рахуємо яка мінімальна кількість монет певного номіналу буде задіяна у видачі решти мені не вдалося отримати різні результати у цих двох алгоритмах. Тобто, яку стартову суму для видачі решти я б не задавав, обидва алгоритми дають абсолютно однакову кількість монет за кожним номіналом для видачи решти. Незалежно від того, велике чи мале число задано.
Проте, коли ми дивимось на швидкість виконання, яку рахуємо за допомогою модулю "timeit", ми бачимо такі результати на досить великій сумі(11_545):

-------------------------------------------------------
Функція                        | Час виконання, секунди
-------------------------------------------------------
find_coins_greedy              | 2.1799933165311813e-05
find_min_coins                 | 0.18614300014451146

І на маленькій сумі(11):
-------------------------------------------------------
Функція                        | Час виконання, секунди
-------------------------------------------------------
find_coins_greedy              | 1.4600344002246857e-05
find_min_coins                 | 8.560018613934517e-05

- де "find_coins_greedy" - це результати жадібного алгоритму, а "find_min_coins" - результати алгоритму динамічного програмування.

Тобто, в даному випадку, ефективність жадібного алгоритму значно перевищує ефективність алгоритму динамічного програмування. І чим більше число - тим більше ця різниця. Це обумовлено часовою складністю цих алгоритмів - згідно з результатами у цій конкретній задачі вона виявилася вищою в алгоритма динамічного програмування.
